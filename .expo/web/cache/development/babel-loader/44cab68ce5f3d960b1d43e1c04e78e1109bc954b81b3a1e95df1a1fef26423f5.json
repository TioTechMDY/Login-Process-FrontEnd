{"ast":null,"code":"export function normalizeParams() {\n  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n  var bindParams = params.length > 1 ? params : params[0];\n  if (bindParams == null) {\n    bindParams = [];\n  }\n  if (typeof bindParams !== 'object' || bindParams instanceof ArrayBuffer || ArrayBuffer.isView(bindParams)) {\n    bindParams = [bindParams];\n  }\n  var shouldPassAsArray = Array.isArray(bindParams);\n  if (Array.isArray(bindParams)) {\n    bindParams = bindParams.reduce(function (acc, value, index) {\n      acc[index] = value;\n      return acc;\n    }, {});\n  }\n  var primitiveParams = {};\n  var blobParams = {};\n  for (var key in bindParams) {\n    var value = bindParams[key];\n    if (value instanceof Uint8Array) {\n      blobParams[key] = value;\n    } else {\n      primitiveParams[key] = value;\n    }\n  }\n  return [primitiveParams, blobParams, shouldPassAsArray];\n}\nexport function composeRow(columnNames, columnValues) {\n  var row = {};\n  if (columnNames.length !== columnValues.length) {\n    throw new Error(`Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValues.length}`);\n  }\n  for (var i = 0; i < columnNames.length; i++) {\n    row[columnNames[i]] = columnValues[i];\n  }\n  return row;\n}\nexport function composeRows(columnNames, columnValuesList) {\n  if (columnValuesList.length === 0) {\n    return [];\n  }\n  if (columnNames.length !== columnValuesList[0].length) {\n    throw new Error(`Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValuesList[0].length}`);\n  }\n  var results = [];\n  for (var columnValues of columnValuesList) {\n    var row = {};\n    for (var i = 0; i < columnNames.length; i++) {\n      row[columnNames[i]] = columnValues[i];\n    }\n    results.push(row);\n  }\n  return results;\n}","map":{"version":3,"names":["normalizeParams","_len","arguments","length","params","Array","_key","bindParams","ArrayBuffer","isView","shouldPassAsArray","isArray","reduce","acc","value","index","primitiveParams","blobParams","key","Uint8Array","composeRow","columnNames","columnValues","row","Error","i","composeRows","columnValuesList","results","push"],"sources":["D:\\Development\\React_nactive\\login_process\\frontend\\node_modules\\expo-sqlite\\src\\paramUtils.ts"],"sourcesContent":["import {\n  SQLiteBindBlobParams,\n  SQLiteBindParams,\n  SQLiteBindPrimitiveParams,\n  SQLiteBindValue,\n  type SQLiteColumnNames,\n  type SQLiteColumnValues,\n} from './NativeStatement';\n\n/**\n * Normalize the bind params to data structure that can be passed to native module.\n * The data structure is a tuple of [primitiveParams, blobParams, shouldPassAsArray].\n * @hidden\n */\nexport function normalizeParams(\n  ...params: any[]\n): [SQLiteBindPrimitiveParams, SQLiteBindBlobParams, boolean] {\n  let bindParams = params.length > 1 ? params : (params[0] as SQLiteBindParams);\n  if (bindParams == null) {\n    bindParams = [];\n  }\n  if (\n    typeof bindParams !== 'object' ||\n    bindParams instanceof ArrayBuffer ||\n    ArrayBuffer.isView(bindParams)\n  ) {\n    bindParams = [bindParams];\n  }\n  const shouldPassAsArray = Array.isArray(bindParams);\n  if (Array.isArray(bindParams)) {\n    bindParams = bindParams.reduce<Record<string, SQLiteBindValue>>((acc, value, index) => {\n      acc[index] = value;\n      return acc;\n    }, {});\n  }\n\n  const primitiveParams: SQLiteBindPrimitiveParams = {};\n  const blobParams: SQLiteBindBlobParams = {};\n  for (const key in bindParams) {\n    const value = bindParams[key];\n    if (value instanceof Uint8Array) {\n      blobParams[key] = value;\n    } else {\n      primitiveParams[key] = value;\n    }\n  }\n\n  return [primitiveParams, blobParams, shouldPassAsArray];\n}\n\n/**\n * Compose `columnNames` and `columnValues` to an row object.\n * @hidden\n */\nexport function composeRow<T>(columnNames: SQLiteColumnNames, columnValues: SQLiteColumnValues): T {\n  const row = {};\n  if (columnNames.length !== columnValues.length) {\n    throw new Error(\n      `Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValues.length}`\n    );\n  }\n  for (let i = 0; i < columnNames.length; i++) {\n    row[columnNames[i]] = columnValues[i];\n  }\n  return row as T;\n}\n\n/**\n * Compose `columnNames` and `columnValuesList` to an array of row objects.\n * @hidden\n */\nexport function composeRows<T>(\n  columnNames: SQLiteColumnNames,\n  columnValuesList: SQLiteColumnValues[]\n): T[] {\n  if (columnValuesList.length === 0) {\n    return [];\n  }\n  if (columnNames.length !== columnValuesList[0].length) {\n    // We only check the first row because SQLite returns the same column count for all rows.\n    throw new Error(\n      `Column names and values count mismatch. Names: ${columnNames.length}, Values: ${columnValuesList[0].length}`\n    );\n  }\n  const results: T[] = [];\n  for (const columnValues of columnValuesList) {\n    const row = {};\n    for (let i = 0; i < columnNames.length; i++) {\n      row[columnNames[i]] = columnValues[i];\n    }\n    results.push(row as T);\n  }\n  return results;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}