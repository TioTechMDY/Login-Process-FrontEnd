{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/wrapAsyncGenerator\";\nimport { composeRow, composeRows, normalizeParams } from './paramUtils';\nexport var SQLiteStatement = function () {\n  function SQLiteStatement(nativeDatabase, nativeStatement) {\n    _classCallCheck(this, SQLiteStatement);\n    this.nativeDatabase = nativeDatabase;\n    this.nativeStatement = nativeStatement;\n  }\n  return _createClass(SQLiteStatement, [{\n    key: \"executeAsync\",\n    value: function () {\n      var _executeAsync = _asyncToGenerator(function* () {\n        var _this$nativeStatement;\n        var _yield$this$nativeSta = yield (_this$nativeStatement = this.nativeStatement).runAsync.apply(_this$nativeStatement, [this.nativeDatabase].concat(_toConsumableArray(normalizeParams.apply(void 0, arguments)))),\n          lastInsertRowId = _yield$this$nativeSta.lastInsertRowId,\n          changes = _yield$this$nativeSta.changes,\n          firstRowValues = _yield$this$nativeSta.firstRowValues;\n        return createSQLiteExecuteAsyncResult(this.nativeDatabase, this.nativeStatement, firstRowValues, {\n          rawResult: false,\n          lastInsertRowId: lastInsertRowId,\n          changes: changes\n        });\n      });\n      function executeAsync() {\n        return _executeAsync.apply(this, arguments);\n      }\n      return executeAsync;\n    }()\n  }, {\n    key: \"executeForRawResultAsync\",\n    value: function () {\n      var _executeForRawResultAsync = _asyncToGenerator(function* () {\n        var _this$nativeStatement2;\n        var _yield$this$nativeSta2 = yield (_this$nativeStatement2 = this.nativeStatement).runAsync.apply(_this$nativeStatement2, [this.nativeDatabase].concat(_toConsumableArray(normalizeParams.apply(void 0, arguments)))),\n          lastInsertRowId = _yield$this$nativeSta2.lastInsertRowId,\n          changes = _yield$this$nativeSta2.changes,\n          firstRowValues = _yield$this$nativeSta2.firstRowValues;\n        return createSQLiteExecuteAsyncResult(this.nativeDatabase, this.nativeStatement, firstRowValues, {\n          rawResult: true,\n          lastInsertRowId: lastInsertRowId,\n          changes: changes\n        });\n      });\n      function executeForRawResultAsync() {\n        return _executeForRawResultAsync.apply(this, arguments);\n      }\n      return executeForRawResultAsync;\n    }()\n  }, {\n    key: \"getColumnNamesAsync\",\n    value: function getColumnNamesAsync() {\n      return this.nativeStatement.getColumnNamesAsync();\n    }\n  }, {\n    key: \"finalizeAsync\",\n    value: (function () {\n      var _finalizeAsync = _asyncToGenerator(function* () {\n        yield this.nativeStatement.finalizeAsync(this.nativeDatabase);\n      });\n      function finalizeAsync() {\n        return _finalizeAsync.apply(this, arguments);\n      }\n      return finalizeAsync;\n    }())\n  }, {\n    key: \"executeSync\",\n    value: function executeSync() {\n      var _this$nativeStatement4;\n      var _this$nativeStatement3 = (_this$nativeStatement4 = this.nativeStatement).runSync.apply(_this$nativeStatement4, [this.nativeDatabase].concat(_toConsumableArray(normalizeParams.apply(void 0, arguments)))),\n        lastInsertRowId = _this$nativeStatement3.lastInsertRowId,\n        changes = _this$nativeStatement3.changes,\n        firstRowValues = _this$nativeStatement3.firstRowValues;\n      return createSQLiteExecuteSyncResult(this.nativeDatabase, this.nativeStatement, firstRowValues, {\n        rawResult: false,\n        lastInsertRowId: lastInsertRowId,\n        changes: changes\n      });\n    }\n  }, {\n    key: \"executeForRawResultSync\",\n    value: function executeForRawResultSync() {\n      var _this$nativeStatement6;\n      var _this$nativeStatement5 = (_this$nativeStatement6 = this.nativeStatement).runSync.apply(_this$nativeStatement6, [this.nativeDatabase].concat(_toConsumableArray(normalizeParams.apply(void 0, arguments)))),\n        lastInsertRowId = _this$nativeStatement5.lastInsertRowId,\n        changes = _this$nativeStatement5.changes,\n        firstRowValues = _this$nativeStatement5.firstRowValues;\n      return createSQLiteExecuteSyncResult(this.nativeDatabase, this.nativeStatement, firstRowValues, {\n        rawResult: true,\n        lastInsertRowId: lastInsertRowId,\n        changes: changes\n      });\n    }\n  }, {\n    key: \"getColumnNamesSync\",\n    value: function getColumnNamesSync() {\n      return this.nativeStatement.getColumnNamesSync();\n    }\n  }, {\n    key: \"finalizeSync\",\n    value: function finalizeSync() {\n      this.nativeStatement.finalizeSync(this.nativeDatabase);\n    }\n  }]);\n}();\nfunction createSQLiteExecuteAsyncResult(_x, _x2, _x3, _x4) {\n  return _createSQLiteExecuteAsyncResult.apply(this, arguments);\n}\nfunction _createSQLiteExecuteAsyncResult() {\n  _createSQLiteExecuteAsyncResult = _asyncToGenerator(function* (database, statement, firstRowValues, options) {\n    var instance = new SQLiteExecuteAsyncResultImpl(database, statement, firstRowValues, options);\n    var generator = instance.generatorAsync();\n    Object.defineProperties(generator, {\n      lastInsertRowId: {\n        value: options.lastInsertRowId,\n        enumerable: true,\n        writable: false,\n        configurable: true\n      },\n      changes: {\n        value: options.changes,\n        enumerable: true,\n        writable: false,\n        configurable: true\n      },\n      getFirstAsync: {\n        value: instance.getFirstAsync.bind(instance),\n        enumerable: true,\n        writable: false,\n        configurable: true\n      },\n      getAllAsync: {\n        value: instance.getAllAsync.bind(instance),\n        enumerable: true,\n        writable: false,\n        configurable: true\n      },\n      resetAsync: {\n        value: instance.resetAsync.bind(instance),\n        enumerable: true,\n        writable: false,\n        configurable: true\n      }\n    });\n    return generator;\n  });\n  return _createSQLiteExecuteAsyncResult.apply(this, arguments);\n}\nfunction createSQLiteExecuteSyncResult(database, statement, firstRowValues, options) {\n  var instance = new SQLiteExecuteSyncResultImpl(database, statement, firstRowValues, options);\n  var generator = instance.generatorSync();\n  Object.defineProperties(generator, {\n    lastInsertRowId: {\n      value: options.lastInsertRowId,\n      enumerable: true,\n      writable: false,\n      configurable: true\n    },\n    changes: {\n      value: options.changes,\n      enumerable: true,\n      writable: false,\n      configurable: true\n    },\n    getFirstSync: {\n      value: instance.getFirstSync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true\n    },\n    getAllSync: {\n      value: instance.getAllSync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true\n    },\n    resetSync: {\n      value: instance.resetSync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true\n    }\n  });\n  return generator;\n}\nvar SQLiteExecuteAsyncResultImpl = function () {\n  function SQLiteExecuteAsyncResultImpl(database, statement, firstRowValues, options) {\n    _classCallCheck(this, SQLiteExecuteAsyncResultImpl);\n    this.columnNames = null;\n    this.isStepCalled = false;\n    this.database = database;\n    this.statement = statement;\n    this.firstRowValues = firstRowValues;\n    this.options = options;\n  }\n  return _createClass(SQLiteExecuteAsyncResultImpl, [{\n    key: \"getFirstAsync\",\n    value: function () {\n      var _getFirstAsync = _asyncToGenerator(function* () {\n        if (this.isStepCalled) {\n          throw new Error('The SQLite cursor has been shifted and is unable to retrieve the first row without being reset. Invoke `resetAsync()` to reset the cursor first if you want to retrieve the first row.');\n        }\n        this.isStepCalled = true;\n        var columnNames = yield this.getColumnNamesAsync();\n        var firstRowValues = this.popFirstRowValues();\n        if (firstRowValues != null) {\n          return composeRowIfNeeded(this.options.rawResult, columnNames, firstRowValues);\n        }\n        var firstRow = yield this.statement.stepAsync(this.database);\n        return firstRow != null ? composeRowIfNeeded(this.options.rawResult, columnNames, firstRow) : null;\n      });\n      function getFirstAsync() {\n        return _getFirstAsync.apply(this, arguments);\n      }\n      return getFirstAsync;\n    }()\n  }, {\n    key: \"getAllAsync\",\n    value: function () {\n      var _getAllAsync = _asyncToGenerator(function* () {\n        if (this.isStepCalled) {\n          throw new Error('The SQLite cursor has been shifted and is unable to retrieve all rows without being reset. Invoke `resetAsync()` to reset the cursor first if you want to retrieve all rows.');\n        }\n        this.isStepCalled = true;\n        var firstRowValues = this.popFirstRowValues();\n        if (firstRowValues == null) {\n          return [];\n        }\n        var columnNames = yield this.getColumnNamesAsync();\n        var allRows = yield this.statement.getAllAsync(this.database);\n        if (firstRowValues != null && firstRowValues.length > 0) {\n          return composeRowsIfNeeded(this.options.rawResult, columnNames, [firstRowValues].concat(_toConsumableArray(allRows)));\n        }\n        return composeRowsIfNeeded(this.options.rawResult, columnNames, allRows);\n      });\n      function getAllAsync() {\n        return _getAllAsync.apply(this, arguments);\n      }\n      return getAllAsync;\n    }()\n  }, {\n    key: \"generatorAsync\",\n    value: function generatorAsync() {\n      var _this = this;\n      return _wrapAsyncGenerator(function* () {\n        _this.isStepCalled = true;\n        var columnNames = yield _awaitAsyncGenerator(_this.getColumnNamesAsync());\n        var firstRowValues = _this.popFirstRowValues();\n        if (firstRowValues != null) {\n          yield composeRowIfNeeded(_this.options.rawResult, columnNames, firstRowValues);\n        }\n        var result;\n        do {\n          result = yield _awaitAsyncGenerator(_this.statement.stepAsync(_this.database));\n          if (result != null) {\n            yield composeRowIfNeeded(_this.options.rawResult, columnNames, result);\n          }\n        } while (result != null);\n      })();\n    }\n  }, {\n    key: \"resetAsync\",\n    value: function resetAsync() {\n      var result = this.statement.resetAsync(this.database);\n      this.isStepCalled = false;\n      return result;\n    }\n  }, {\n    key: \"popFirstRowValues\",\n    value: function popFirstRowValues() {\n      if (this.firstRowValues != null) {\n        var firstRowValues = this.firstRowValues;\n        this.firstRowValues = null;\n        return firstRowValues.length > 0 ? firstRowValues : null;\n      }\n      return null;\n    }\n  }, {\n    key: \"getColumnNamesAsync\",\n    value: function () {\n      var _getColumnNamesAsync = _asyncToGenerator(function* () {\n        if (this.columnNames == null) {\n          this.columnNames = yield this.statement.getColumnNamesAsync();\n        }\n        return this.columnNames;\n      });\n      function getColumnNamesAsync() {\n        return _getColumnNamesAsync.apply(this, arguments);\n      }\n      return getColumnNamesAsync;\n    }()\n  }]);\n}();\nvar SQLiteExecuteSyncResultImpl = function () {\n  function SQLiteExecuteSyncResultImpl(database, statement, firstRowValues, options) {\n    _classCallCheck(this, SQLiteExecuteSyncResultImpl);\n    this.columnNames = null;\n    this.isStepCalled = false;\n    this.database = database;\n    this.statement = statement;\n    this.firstRowValues = firstRowValues;\n    this.options = options;\n  }\n  return _createClass(SQLiteExecuteSyncResultImpl, [{\n    key: \"getFirstSync\",\n    value: function getFirstSync() {\n      if (this.isStepCalled) {\n        throw new Error('The SQLite cursor has been shifted and is unable to retrieve the first row without being reset. Invoke `resetSync()` to reset the cursor first if you want to retrieve the first row.');\n      }\n      var columnNames = this.getColumnNamesSync();\n      var firstRowValues = this.popFirstRowValues();\n      if (firstRowValues != null) {\n        return composeRowIfNeeded(this.options.rawResult, columnNames, firstRowValues);\n      }\n      var firstRow = this.statement.stepSync(this.database);\n      return firstRow != null ? composeRowIfNeeded(this.options.rawResult, columnNames, firstRow) : null;\n    }\n  }, {\n    key: \"getAllSync\",\n    value: function getAllSync() {\n      if (this.isStepCalled) {\n        throw new Error('The SQLite cursor has been shifted and is unable to retrieve all rows without being reset. Invoke `resetSync()` to reset the cursor first if you want to retrieve all rows.');\n      }\n      var firstRowValues = this.popFirstRowValues();\n      if (firstRowValues == null) {\n        return [];\n      }\n      var columnNames = this.getColumnNamesSync();\n      var allRows = this.statement.getAllSync(this.database);\n      if (firstRowValues != null && firstRowValues.length > 0) {\n        return composeRowsIfNeeded(this.options.rawResult, columnNames, [firstRowValues].concat(_toConsumableArray(allRows)));\n      }\n      return composeRowsIfNeeded(this.options.rawResult, columnNames, allRows);\n    }\n  }, {\n    key: \"generatorSync\",\n    value: function* generatorSync() {\n      var columnNames = this.getColumnNamesSync();\n      var firstRowValues = this.popFirstRowValues();\n      if (firstRowValues != null) {\n        yield composeRowIfNeeded(this.options.rawResult, columnNames, firstRowValues);\n      }\n      var result;\n      do {\n        result = this.statement.stepSync(this.database);\n        if (result != null) {\n          yield composeRowIfNeeded(this.options.rawResult, columnNames, result);\n        }\n      } while (result != null);\n    }\n  }, {\n    key: \"resetSync\",\n    value: function resetSync() {\n      var result = this.statement.resetSync(this.database);\n      this.isStepCalled = false;\n      return result;\n    }\n  }, {\n    key: \"popFirstRowValues\",\n    value: function popFirstRowValues() {\n      if (this.firstRowValues != null) {\n        var firstRowValues = this.firstRowValues;\n        this.firstRowValues = null;\n        return firstRowValues.length > 0 ? firstRowValues : null;\n      }\n      return null;\n    }\n  }, {\n    key: \"getColumnNamesSync\",\n    value: function getColumnNamesSync() {\n      if (this.columnNames == null) {\n        this.columnNames = this.statement.getColumnNamesSync();\n      }\n      return this.columnNames;\n    }\n  }]);\n}();\nfunction composeRowIfNeeded(rawResult, columnNames, columnValues) {\n  return rawResult ? columnValues : composeRow(columnNames, columnValues);\n}\nfunction composeRowsIfNeeded(rawResult, columnNames, columnValuesList) {\n  return rawResult ? columnValuesList : composeRows(columnNames, columnValuesList);\n}","map":{"version":3,"names":["composeRow","composeRows","normalizeParams","SQLiteStatement","nativeDatabase","nativeStatement","_classCallCheck","_createClass","key","value","_executeAsync","_asyncToGenerator","_this$nativeStatement","_yield$this$nativeSta","runAsync","apply","concat","_toConsumableArray","arguments","lastInsertRowId","changes","firstRowValues","createSQLiteExecuteAsyncResult","rawResult","executeAsync","_executeForRawResultAsync","_this$nativeStatement2","_yield$this$nativeSta2","executeForRawResultAsync","getColumnNamesAsync","_finalizeAsync","finalizeAsync","executeSync","_this$nativeStatement4","_this$nativeStatement3","runSync","createSQLiteExecuteSyncResult","executeForRawResultSync","_this$nativeStatement6","_this$nativeStatement5","getColumnNamesSync","finalizeSync","_x","_x2","_x3","_x4","_createSQLiteExecuteAsyncResult","database","statement","options","instance","SQLiteExecuteAsyncResultImpl","generator","generatorAsync","Object","defineProperties","enumerable","writable","configurable","getFirstAsync","bind","getAllAsync","resetAsync","SQLiteExecuteSyncResultImpl","generatorSync","getFirstSync","getAllSync","resetSync","columnNames","isStepCalled","_getFirstAsync","Error","popFirstRowValues","composeRowIfNeeded","firstRow","stepAsync","_getAllAsync","allRows","length","composeRowsIfNeeded","_this","_wrapAsyncGenerator","_awaitAsyncGenerator","result","_getColumnNamesAsync","stepSync","columnValues","columnValuesList"],"sources":["D:\\Development\\React_nactive\\login_process\\frontend\\node_modules\\expo-sqlite\\src\\SQLiteStatement.ts"],"sourcesContent":["import { NativeDatabase } from './NativeDatabase';\nimport {\n  SQLiteBindParams,\n  SQLiteBindValue,\n  NativeStatement,\n  SQLiteVariadicBindParams,\n  type SQLiteAnyDatabase,\n  type SQLiteColumnNames,\n  type SQLiteColumnValues,\n  type SQLiteRunResult,\n} from './NativeStatement';\nimport { composeRow, composeRows, normalizeParams } from './paramUtils';\n\nexport { SQLiteBindParams, SQLiteBindValue, SQLiteRunResult, SQLiteVariadicBindParams };\n\ntype ValuesOf<T extends object> = T[keyof T][];\n\n/**\n * A prepared statement returned by [`SQLiteDatabase.prepareAsync()`](#prepareasyncsource) or [`SQLiteDatabase.prepareSync()`](#preparesyncsource) that can be binded with parameters and executed.\n */\nexport class SQLiteStatement {\n  constructor(\n    private readonly nativeDatabase: NativeDatabase,\n    private readonly nativeStatement: NativeStatement\n  ) {}\n\n  //#region Asynchronous API\n\n  /**\n   * Run the prepared statement and return the [`SQLiteExecuteAsyncResult`](#sqliteexecuteasyncresult) instance.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public executeAsync<T>(params: SQLiteBindParams): Promise<SQLiteExecuteAsyncResult<T>>;\n  /**\n   * @hidden\n   */\n  public executeAsync<T>(...params: SQLiteVariadicBindParams): Promise<SQLiteExecuteAsyncResult<T>>;\n  public async executeAsync<T>(...params: unknown[]): Promise<SQLiteExecuteAsyncResult<T>> {\n    const { lastInsertRowId, changes, firstRowValues } = await this.nativeStatement.runAsync(\n      this.nativeDatabase,\n      ...normalizeParams(...params)\n    );\n    return createSQLiteExecuteAsyncResult<T>(\n      this.nativeDatabase,\n      this.nativeStatement,\n      firstRowValues,\n      {\n        rawResult: false,\n        lastInsertRowId,\n        changes,\n      }\n    );\n  }\n\n  /**\n   * Similar to [`executeAsync()`](#executeasyncparams) but returns the raw value array result instead of the row objects.\n   * @hidden Advanced use only.\n   */\n  public executeForRawResultAsync<T extends object>(\n    params: SQLiteBindParams\n  ): Promise<SQLiteExecuteAsyncResult<ValuesOf<T>>>;\n  /**\n   * @hidden\n   */\n  public executeForRawResultAsync<T extends object>(\n    ...params: SQLiteVariadicBindParams\n  ): Promise<SQLiteExecuteAsyncResult<ValuesOf<T>>>;\n  public async executeForRawResultAsync<T extends object>(\n    ...params: unknown[]\n  ): Promise<SQLiteExecuteAsyncResult<ValuesOf<T>>> {\n    const { lastInsertRowId, changes, firstRowValues } = await this.nativeStatement.runAsync(\n      this.nativeDatabase,\n      ...normalizeParams(...params)\n    );\n    return createSQLiteExecuteAsyncResult<ValuesOf<T>>(\n      this.nativeDatabase,\n      this.nativeStatement,\n      firstRowValues,\n      {\n        rawResult: true,\n        lastInsertRowId,\n        changes,\n      }\n    );\n  }\n\n  /**\n   * Get the column names of the prepared statement.\n   */\n  public getColumnNamesAsync(): Promise<string[]> {\n    return this.nativeStatement.getColumnNamesAsync();\n  }\n\n  /**\n   * Finalize the prepared statement. This will call the [`sqlite3_finalize()`](https://www.sqlite.org/c3ref/finalize.html) C function under the hood.\n   *\n   * Attempting to access a finalized statement will result in an error.\n   * > **Note:** While expo-sqlite will automatically finalize any orphaned prepared statements upon closing the database, it is considered best practice to manually finalize prepared statements as soon as they are no longer needed. This helps to prevent resource leaks. You can use the `try...finally` statement to ensure that prepared statements are finalized even if an error occurs.\n   */\n  public async finalizeAsync(): Promise<void> {\n    await this.nativeStatement.finalizeAsync(this.nativeDatabase);\n  }\n\n  //#endregion\n\n  //#region Synchronous API\n\n  /**\n   * Run the prepared statement and return the [`SQLiteExecuteSyncResult`](#sqliteexecutesyncresult) instance.\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   * @param params The parameters to bind to the prepared statement. You can pass values in array, object, or variadic arguments. See [`SQLiteBindValue`](#sqlitebindvalue) for more information about binding values.\n   */\n  public executeSync<T>(params: SQLiteBindParams): SQLiteExecuteSyncResult<T>;\n  /**\n   * @hidden\n   */\n  public executeSync<T>(...params: SQLiteVariadicBindParams): SQLiteExecuteSyncResult<T>;\n  public executeSync<T>(...params: unknown[]): SQLiteExecuteSyncResult<T> {\n    const { lastInsertRowId, changes, firstRowValues } = this.nativeStatement.runSync(\n      this.nativeDatabase,\n      ...normalizeParams(...params)\n    );\n    return createSQLiteExecuteSyncResult<T>(\n      this.nativeDatabase,\n      this.nativeStatement,\n      firstRowValues,\n      {\n        rawResult: false,\n        lastInsertRowId,\n        changes,\n      }\n    );\n  }\n\n  /**\n   * Similar to [`executeSync()`](#executesyncparams) but returns the raw value array result instead of the row objects.\n   * @hidden Advanced use only.\n   */\n  public executeForRawResultSync<T extends object>(\n    params: SQLiteBindParams\n  ): SQLiteExecuteSyncResult<ValuesOf<T>>;\n  /**\n   * @hidden\n   */\n  public executeForRawResultSync<T extends object>(\n    ...params: SQLiteVariadicBindParams\n  ): SQLiteExecuteSyncResult<ValuesOf<T>>;\n  public executeForRawResultSync<T extends object>(\n    ...params: unknown[]\n  ): SQLiteExecuteSyncResult<ValuesOf<T>> {\n    const { lastInsertRowId, changes, firstRowValues } = this.nativeStatement.runSync(\n      this.nativeDatabase,\n      ...normalizeParams(...params)\n    );\n    return createSQLiteExecuteSyncResult<ValuesOf<T>>(\n      this.nativeDatabase,\n      this.nativeStatement,\n      firstRowValues,\n      {\n        rawResult: true,\n        lastInsertRowId,\n        changes,\n      }\n    );\n  }\n\n  /**\n   * Get the column names of the prepared statement.\n   */\n  public getColumnNamesSync(): string[] {\n    return this.nativeStatement.getColumnNamesSync();\n  }\n\n  /**\n   * Finalize the prepared statement. This will call the [`sqlite3_finalize()`](https://www.sqlite.org/c3ref/finalize.html) C function under the hood.\n   *\n   * Attempting to access a finalized statement will result in an error.\n   * > **Note:** While expo-sqlite will automatically finalize any orphaned prepared statements upon closing the database, it is considered best practice to manually finalize prepared statements as soon as they are no longer needed. This helps to prevent resource leaks. You can use the `try...finally` statement to ensure that prepared statements are finalized even if an error occurs.\n   */\n  public finalizeSync(): void {\n    this.nativeStatement.finalizeSync(this.nativeDatabase);\n  }\n\n  //#endregion\n}\n\n/**\n * A result returned by [`SQLiteStatement.executeAsync()`](#executeasyncparams).\n *\n * @example\n * The result includes the [`lastInsertRowId`](https://www.sqlite.org/c3ref/last_insert_rowid.html) and [`changes`](https://www.sqlite.org/c3ref/changes.html) properties. You can get the information from the write operations.\n * ```ts\n * const statement = await db.prepareAsync('INSERT INTO test (value) VALUES (?)');\n * try {\n *   const result = await statement.executeAsync(101);\n *   console.log('lastInsertRowId:', result.lastInsertRowId);\n *   console.log('changes:', result.changes);\n * } finally {\n *   await statement.finalizeAsync();\n * }\n * ```\n *\n * @example\n * The result implements the [`AsyncIterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator) interface, so you can use it in `for await...of` loops.\n * ```ts\n * const statement = await db.prepareAsync('SELECT value FROM test WHERE value > ?');\n * try {\n *   const result = await statement.executeAsync<{ value: number }>(100);\n *   for await (const row of result) {\n *     console.log('row value:', row.value);\n *   }\n * } finally {\n *   await statement.finalizeAsync();\n * }\n * ```\n *\n * @example\n * If your write operations also return values, you can mix all of them together.\n * ```ts\n * const statement = await db.prepareAsync('INSERT INTO test (name, value) VALUES (?, ?) RETURNING name');\n * try {\n *   const result = await statement.executeAsync<{ name: string }>('John Doe', 101);\n *   console.log('lastInsertRowId:', result.lastInsertRowId);\n *   console.log('changes:', result.changes);\n *   for await (const row of result) {\n *     console.log('name:', row.name);\n *   }\n * } finally {\n *   await statement.finalizeAsync();\n * }\n * ```\n */\nexport interface SQLiteExecuteAsyncResult<T> extends AsyncIterableIterator<T> {\n  /**\n   * The last inserted row ID. Returned from the [`sqlite3_last_insert_rowid()`](https://www.sqlite.org/c3ref/last_insert_rowid.html) function.\n   */\n  readonly lastInsertRowId: number;\n\n  /**\n   * The number of rows affected. Returned from the [`sqlite3_changes()`](https://www.sqlite.org/c3ref/changes.html) function.\n   */\n  readonly changes: number;\n\n  /**\n   * Get the first row of the result set. This requires the SQLite cursor to be in its initial state. If you have already retrieved rows from the result set, you need to reset the cursor first by calling [`resetAsync()`](#resetasync). Otherwise, an error will be thrown.\n   */\n  getFirstAsync(): Promise<T | null>;\n\n  /**\n   * Get all rows of the result set. This requires the SQLite cursor to be in its initial state. If you have already retrieved rows from the result set, you need to reset the cursor first by calling [`resetAsync()`](#resetasync). Otherwise, an error will be thrown.\n   */\n  getAllAsync(): Promise<T[]>;\n\n  /**\n   * Reset the prepared statement cursor. This will call the [`sqlite3_reset()`](https://www.sqlite.org/c3ref/reset.html) C function under the hood.\n   */\n  resetAsync(): Promise<void>;\n}\n\n/**\n * A result returned by [`SQLiteStatement.executeSync()`](#executesyncparams).\n * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n\n * @example\n * The result includes the [`lastInsertRowId`](https://www.sqlite.org/c3ref/last_insert_rowid.html) and [`changes`](https://www.sqlite.org/c3ref/changes.html) properties. You can get the information from the write operations.\n * ```ts\n * const statement = db.prepareSync('INSERT INTO test (value) VALUES (?)');\n * try {\n *   const result = statement.executeSync(101);\n *   console.log('lastInsertRowId:', result.lastInsertRowId);\n *   console.log('changes:', result.changes);\n * } finally {\n *   statement.finalizeSync();\n * }\n * ```\n *\n * @example\n * The result implements the [`Iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator) interface, so you can use it in `for...of` loops.\n * ```ts\n * const statement = db.prepareSync('SELECT value FROM test WHERE value > ?');\n * try {\n *   const result = statement.executeSync<{ value: number }>(100);\n *   for (const row of result) {\n *     console.log('row value:', row.value);\n *   }\n * } finally {\n *   statement.finalizeSync();\n * }\n * ```\n *\n * @example\n * If your write operations also return values, you can mix all of them together.\n * ```ts\n * const statement = db.prepareSync('INSERT INTO test (name, value) VALUES (?, ?) RETURNING name');\n * try {\n *   const result = statement.executeSync<{ name: string }>('John Doe', 101);\n *   console.log('lastInsertRowId:', result.lastInsertRowId);\n *   console.log('changes:', result.changes);\n *   for (const row of result) {\n *     console.log('name:', row.name);\n *   }\n * } finally {\n *   statement.finalizeSync();\n * }\n * ```\n */\nexport interface SQLiteExecuteSyncResult<T> extends IterableIterator<T> {\n  /**\n   * The last inserted row ID. Returned from the [`sqlite3_last_insert_rowid()`](https://www.sqlite.org/c3ref/last_insert_rowid.html) function.\n   */\n  readonly lastInsertRowId: number;\n\n  /**\n   * The number of rows affected. Returned from the [`sqlite3_changes()`](https://www.sqlite.org/c3ref/changes.html) function.\n   */\n  readonly changes: number;\n\n  /**\n   * Get the first row of the result set. This requires the SQLite cursor to be in its initial state. If you have already retrieved rows from the result set, you need to reset the cursor first by calling [`resetSync()`](#resetsync). Otherwise, an error will be thrown.\n   */\n  getFirstSync(): T | null;\n\n  /**\n   * Get all rows of the result set. This requires the SQLite cursor to be in its initial state. If you have already retrieved rows from the result set, you need to reset the cursor first by calling [`resetSync()`](#resetsync). Otherwise, an error will be thrown.\n   */\n  getAllSync(): T[];\n\n  /**\n   * Reset the prepared statement cursor. This will call the [`sqlite3_reset()`](https://www.sqlite.org/c3ref/reset.html) C function under the hood.\n   */\n  resetSync(): void;\n}\n\n//#region Internals for SQLiteExecuteAsyncResult and SQLiteExecuteSyncResult\n\ninterface SQLiteExecuteResultOptions {\n  rawResult: boolean;\n  lastInsertRowId: number;\n  changes: number;\n}\n\n/**\n * Create the `SQLiteExecuteAsyncResult` instance.\n *\n * NOTE: Since Hermes does not support the `Symbol.asyncIterator` feature, we have to use an AsyncGenerator to implement the `AsyncIterableIterator` interface.\n * This is done by `Object.defineProperties` to add the properties to the AsyncGenerator.\n */\nasync function createSQLiteExecuteAsyncResult<T>(\n  database: SQLiteAnyDatabase,\n  statement: NativeStatement,\n  firstRowValues: SQLiteColumnValues | null,\n  options: SQLiteExecuteResultOptions\n): Promise<SQLiteExecuteAsyncResult<T>> {\n  const instance = new SQLiteExecuteAsyncResultImpl<T>(\n    database,\n    statement,\n    firstRowValues,\n    options\n  );\n  const generator = instance.generatorAsync();\n  Object.defineProperties(generator, {\n    lastInsertRowId: {\n      value: options.lastInsertRowId,\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n    changes: { value: options.changes, enumerable: true, writable: false, configurable: true },\n    getFirstAsync: {\n      value: instance.getFirstAsync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n    getAllAsync: {\n      value: instance.getAllAsync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n    resetAsync: {\n      value: instance.resetAsync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n  });\n\n  return generator as SQLiteExecuteAsyncResult<T>;\n}\n\n/**\n * Create the `SQLiteExecuteSyncResult` instance.\n */\nfunction createSQLiteExecuteSyncResult<T>(\n  database: SQLiteAnyDatabase,\n  statement: NativeStatement,\n  firstRowValues: SQLiteColumnValues | null,\n  options: SQLiteExecuteResultOptions\n): SQLiteExecuteSyncResult<T> {\n  const instance = new SQLiteExecuteSyncResultImpl<T>(database, statement, firstRowValues, options);\n  const generator = instance.generatorSync();\n  Object.defineProperties(generator, {\n    lastInsertRowId: {\n      value: options.lastInsertRowId,\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n    changes: { value: options.changes, enumerable: true, writable: false, configurable: true },\n    getFirstSync: {\n      value: instance.getFirstSync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n    getAllSync: {\n      value: instance.getAllSync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n    resetSync: {\n      value: instance.resetSync.bind(instance),\n      enumerable: true,\n      writable: false,\n      configurable: true,\n    },\n  });\n\n  return generator as SQLiteExecuteSyncResult<T>;\n}\n\nclass SQLiteExecuteAsyncResultImpl<T> {\n  private columnNames: string[] | null = null;\n  private isStepCalled = false;\n\n  constructor(\n    private readonly database: SQLiteAnyDatabase,\n    private readonly statement: NativeStatement,\n    private firstRowValues: SQLiteColumnValues | null,\n    public readonly options: SQLiteExecuteResultOptions\n  ) {}\n\n  async getFirstAsync(): Promise<T | null> {\n    if (this.isStepCalled) {\n      throw new Error(\n        'The SQLite cursor has been shifted and is unable to retrieve the first row without being reset. Invoke `resetAsync()` to reset the cursor first if you want to retrieve the first row.'\n      );\n    }\n    this.isStepCalled = true;\n    const columnNames = await this.getColumnNamesAsync();\n    const firstRowValues = this.popFirstRowValues();\n    if (firstRowValues != null) {\n      return composeRowIfNeeded<T>(this.options.rawResult, columnNames, firstRowValues);\n    }\n    const firstRow = await this.statement.stepAsync(this.database);\n    return firstRow != null\n      ? composeRowIfNeeded<T>(this.options.rawResult, columnNames, firstRow)\n      : null;\n  }\n\n  async getAllAsync(): Promise<T[]> {\n    if (this.isStepCalled) {\n      throw new Error(\n        'The SQLite cursor has been shifted and is unable to retrieve all rows without being reset. Invoke `resetAsync()` to reset the cursor first if you want to retrieve all rows.'\n      );\n    }\n    this.isStepCalled = true;\n    const firstRowValues = this.popFirstRowValues();\n    if (firstRowValues == null) {\n      // If the first row is empty, this SQL query may be a write operation. We should not call `statement.getAllAsync()` to write again.\n      return [];\n    }\n    const columnNames = await this.getColumnNamesAsync();\n    const allRows = await this.statement.getAllAsync(this.database);\n    if (firstRowValues != null && firstRowValues.length > 0) {\n      return composeRowsIfNeeded<T>(this.options.rawResult, columnNames, [\n        firstRowValues,\n        ...allRows,\n      ]);\n    }\n    return composeRowsIfNeeded<T>(this.options.rawResult, columnNames, allRows);\n  }\n\n  async *generatorAsync(): AsyncIterableIterator<T> {\n    this.isStepCalled = true;\n    const columnNames = await this.getColumnNamesAsync();\n    const firstRowValues = this.popFirstRowValues();\n    if (firstRowValues != null) {\n      yield composeRowIfNeeded<T>(this.options.rawResult, columnNames, firstRowValues);\n    }\n\n    let result;\n    do {\n      result = await this.statement.stepAsync(this.database);\n      if (result != null) {\n        yield composeRowIfNeeded<T>(this.options.rawResult, columnNames, result);\n      }\n    } while (result != null);\n  }\n\n  resetAsync(): Promise<void> {\n    const result = this.statement.resetAsync(this.database);\n    this.isStepCalled = false;\n    return result;\n  }\n\n  private popFirstRowValues(): SQLiteColumnValues | null {\n    if (this.firstRowValues != null) {\n      const firstRowValues = this.firstRowValues;\n      this.firstRowValues = null;\n      return firstRowValues.length > 0 ? firstRowValues : null;\n    }\n    return null;\n  }\n\n  private async getColumnNamesAsync(): Promise<string[]> {\n    if (this.columnNames == null) {\n      this.columnNames = await this.statement.getColumnNamesAsync();\n    }\n    return this.columnNames;\n  }\n}\n\nclass SQLiteExecuteSyncResultImpl<T> {\n  private columnNames: string[] | null = null;\n  private isStepCalled = false;\n\n  constructor(\n    private readonly database: SQLiteAnyDatabase,\n    private readonly statement: NativeStatement,\n    private firstRowValues: SQLiteColumnValues | null,\n    public readonly options: SQLiteExecuteResultOptions\n  ) {}\n\n  getFirstSync(): T | null {\n    if (this.isStepCalled) {\n      throw new Error(\n        'The SQLite cursor has been shifted and is unable to retrieve the first row without being reset. Invoke `resetSync()` to reset the cursor first if you want to retrieve the first row.'\n      );\n    }\n    const columnNames = this.getColumnNamesSync();\n    const firstRowValues = this.popFirstRowValues();\n    if (firstRowValues != null) {\n      return composeRowIfNeeded<T>(this.options.rawResult, columnNames, firstRowValues);\n    }\n    const firstRow = this.statement.stepSync(this.database);\n    return firstRow != null\n      ? composeRowIfNeeded<T>(this.options.rawResult, columnNames, firstRow)\n      : null;\n  }\n\n  getAllSync(): T[] {\n    if (this.isStepCalled) {\n      throw new Error(\n        'The SQLite cursor has been shifted and is unable to retrieve all rows without being reset. Invoke `resetSync()` to reset the cursor first if you want to retrieve all rows.'\n      );\n    }\n    const firstRowValues = this.popFirstRowValues();\n    if (firstRowValues == null) {\n      // If the first row is empty, this SQL query may be a write operation. We should not call `statement.getAllAsync()` to write again.\n      return [];\n    }\n    const columnNames = this.getColumnNamesSync();\n    const allRows = this.statement.getAllSync(this.database);\n    if (firstRowValues != null && firstRowValues.length > 0) {\n      return composeRowsIfNeeded<T>(this.options.rawResult, columnNames, [\n        firstRowValues,\n        ...allRows,\n      ]);\n    }\n    return composeRowsIfNeeded<T>(this.options.rawResult, columnNames, allRows);\n  }\n\n  *generatorSync(): IterableIterator<T> {\n    const columnNames = this.getColumnNamesSync();\n    const firstRowValues = this.popFirstRowValues();\n    if (firstRowValues != null) {\n      yield composeRowIfNeeded<T>(this.options.rawResult, columnNames, firstRowValues);\n    }\n    let result;\n    do {\n      result = this.statement.stepSync(this.database);\n      if (result != null) {\n        yield composeRowIfNeeded<T>(this.options.rawResult, columnNames, result);\n      }\n    } while (result != null);\n  }\n\n  resetSync(): void {\n    const result = this.statement.resetSync(this.database);\n    this.isStepCalled = false;\n    return result;\n  }\n\n  private popFirstRowValues(): SQLiteColumnValues | null {\n    if (this.firstRowValues != null) {\n      const firstRowValues = this.firstRowValues;\n      this.firstRowValues = null;\n      return firstRowValues.length > 0 ? firstRowValues : null;\n    }\n    return null;\n  }\n\n  private getColumnNamesSync(): string[] {\n    if (this.columnNames == null) {\n      this.columnNames = this.statement.getColumnNamesSync();\n    }\n    return this.columnNames;\n  }\n}\n\nfunction composeRowIfNeeded<T>(\n  rawResult: boolean,\n  columnNames: SQLiteColumnNames,\n  columnValues: SQLiteColumnValues\n): T {\n  return rawResult\n    ? (columnValues as T) // T would be a ValuesOf<> from caller\n    : composeRow<T>(columnNames, columnValues);\n}\n\nfunction composeRowsIfNeeded<T>(\n  rawResult: boolean,\n  columnNames: SQLiteColumnNames,\n  columnValuesList: SQLiteColumnValues[]\n): T[] {\n  return rawResult\n    ? (columnValuesList as T[]) // T[] would be a ValuesOf<>[] from caller\n    : composeRows<T>(columnNames, columnValuesList);\n}\n\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}